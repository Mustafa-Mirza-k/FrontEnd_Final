'use strict';

class DOMHelper {
    /**
     * Attaches events to the given element.
     *
     * @param el
     * @param events
     * @param callback
     * @param options
     */
    static addEventListener(el, events, callback, options = true) {
        for (let i in events) {
            el.addEventListener(events[i], callback, options);
        }
    }
    /**
     * Removes events from the given element.
     *
     * @param el
     * @param events
     * @param callback
     * @param options
     */
    static removeEventListener(el, events, callback, options = true) {
        for (let i in events) {
            el.removeEventListener(events[i], callback, options);
        }
    }
    /**
     * Attaches events to the given element for once.
     *
     * @param el
     * @param events
     * @param callback
     * @param addOptions
     * @param removeOptions
     */
    static addEventListenerOnce(el, events, callback, addOptions = true, removeOptions = true) {
        let cb = (e) => {
            this.removeEventListener(el, events, cb, removeOptions);
            callback(e);
        };
        this.addEventListener(el, events, cb, addOptions);
    }
    /**
     * Checks if target is a clickable element.
     *
     * @param target
     * @param container
     */
    static checkIfTargetIsClickable(target, container) {
        let status = true;
        while (container.contains(target)) {
            if (target.getAttribute("data-src-not-clickable")) {
                status = false;
                break;
            }
            target = target.parentNode;
        }
        return status;
    }
    /**
     * Gets breakpoint key by window size.
     *
     * @param sb
     * @param theme
     */
    static getBreakpointKey({ size, sizeSm, sizeMd, sizeLg, sizeXl }, theme) {
        const width = window.innerWidth;
        let key = size;
        if (sizeSm && width > theme.grid.breakpoint.small)
            key = sizeSm;
        if (sizeMd && width > theme.grid.breakpoint.medium)
            key = sizeMd;
        if (sizeLg && width > theme.grid.breakpoint.large)
            key = sizeLg;
        if (sizeXl && width > theme.grid.breakpoint.xlarge)
            key = sizeXl;
        return key;
    }
    /**
     * Gets scroll parent of the given element.
     *
     * @param el
     */
    static getScrollParent(el) {
        for (let parent = el; (parent = parent.parentElement);) {
            let style = window.getComputedStyle(parent, null);
            if (/(auto|scroll|hidden)/.test(style.overflow + style.overflowX + style.overflowY))
                return parent;
        }
        return null;
    }
    /**
     * Checks if an element can be rendered in the React portal.
     *
     * @param renderInPortal
     */
    static canBeRenderedInPortal(renderInPortal) {
        return (renderInPortal && typeof window !== "undefined" && process.env.NODE_ENV !== "test") ? true : false;
    }
}
DOMHelper.TRANSITION_END = ["transitionend", "webkitTransitionEnd", "mozTransitionEnd", "oTransitionEnd"];
DOMHelper.MOUSE_WHEEL = ["wheel", "mousewheel", "DOMMouseScroll"];
DOMHelper.requestAnimationFrame = typeof window !== 'undefined'
    ?
        window.mozRequestAnimationFrame ||
            window.requestAnimationFrame ||
            window.webkitRequestAnimationFrame ||
            window.oRequestAnimationFrame ||
            window.msRequestAnimationFrame ||
            ((callback) => { window.setTimeout(callback, 1000 / 60); })
    : () => { };
DOMHelper.isServer = typeof window === "undefined";
DOMHelper.isMobile = DOMHelper.isServer ? false : /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

exports.DOMHelper = DOMHelper;
